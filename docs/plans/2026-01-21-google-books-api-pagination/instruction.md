# 背景
DRE における Google Books API からの書籍情報取得（Collect 処理）は、現在 1 リクエスト分のみを前提としており、検索結果が多い場合でもページングを行っていない。
また、継続実行（定期実行）時に取得進捗（startIndex 等）を保持していないため、毎回先頭（startIndex=0）から取得してしまい、無駄な API 呼び出しや重複処理が発生しうる。

# 目的
Google Books API のページング（startIndex / maxResults）に対応し、かつ取得進捗（カーソル）を永続化して次回以降の実行でも継続できるようにする。
枯渇（末尾到達）時はワーニングログを出して当該ジョブの Collect を停止し、手動リセットで再開できるようにする。
jobs.yaml の手動編集を増やさない（カーソル/状態は jobs.yaml に書かない）ことを必須とする。

# スコープ（やること）
## 1. Collect のページング対応（1 run 内）
- Google Books API のレスポンス仕様（totalItems / items / startIndex）を前提に、startIndex を進めながら複数ページを順次取得する
- maxResults は API 上限（最大 40）および既存の取得上限・呼び出し制限を必ず遵守する
- items が空、または startIndex が totalItems に到達/超過した場合を「枯渇」として扱う（詳細は後述）

## 2. 取得進捗（カーソル）の永続化（run をまたいで維持）
- Collect 実行の開始時に、永続ストアからカーソル（startIndex 等）を読み取り、そこから取得を開始する
- Collect 実行の終了時（正常終了・上限到達時）に、次回再開できるようカーソルを保存する
- カーソルのキーは「job 単位」だけでなく「クエリ集合のハッシュ」を含める（job_name + query_set_hash）
  - query_set_hash は毎回 job 設定（queries）から計算し、jobs.yaml へ書き戻さない
  - これによりクエリ変更時の整合を自動化し、手動操作（jobs.yaml 編集）を不要にする

## 3. 枯渇時の停止（warn + stop）
- 「枯渇」判定（例: items が空、または startIndex >= totalItems）になった場合
  - ワーニングログを出力する（job 名・query_set_hash・startIndex・totalItems 等が分かる情報）
  - 当該 (job_name, query_set_hash) の Collect を以後停止する状態として永続化する（次回 run でも即停止できるように）
  - 枯渇後は自動で startIndex=0 に戻して周回しない（停止が要件）

## 4. 手動リセット手段（job 単位で十分）
- ジョブ単位でカーソル/枯渇状態をリセットできる CLI 操作を追加する
  - 対象: 指定 job の全 query_set_hash に紐づく状態をクリア（または startIndex=0 相当へ戻す）
  - 破壊的操作のため確認フラグ（例: --yes）を必須にする
- 目的: 枯渇停止後の再開、運用上のやり直しを jobs.yaml 編集なしで可能にする

## 5. ドキュメント・運用手順の追記
- 新しく導入する「カーソル永続化」「枯渇停止」「手動リセット」について ops / 運用ドキュメントに追記する

# スコープ外（やらないこと）
- 検索条件そのものの仕様変更・拡張（既存の queries を前提）
- Google Books API の並列リクエスト化や大規模な性能最適化
- UI / 外部公開仕様の変更
- jobs.yaml へカーソルやハッシュ値を書き込む設計（状態は設定ファイルに混ぜない）

# 制約・前提
- Google Books API の maxResults 上限（最大 40）を遵守すること
- 既存の API 呼び出し回数制限・日次制限、1 run あたりの最大取得件数（max_per_run 等）を必ず尊重すること
- Collect→Upsert→Select→Mail の既存フローを壊さず、Collect の責務に閉じた変更を基本とする
- 枯渇時は warn を出し停止する（自動周回はしない）
- 進捗状態（startIndex / 枯渇フラグ等）は永続化するが、jobs.yaml には書かない

# 実装上の注意
- カーソル永続化の保存先は既存アーキテクチャに合わせる（DB / state ストア等）。jobs.yaml ではないことが必須
- query_set_hash の計算は「queries の集合（順序の影響を排除できる形）」を前提に安定するようにする
  - 例: クエリ文字列を正規化し、ソートしてからハッシュ化、など（具体は実装者が既存コード流儀に合わせる）
- 上限到達（max_per_run / 呼び出し制限）で終了する場合は「枯渇」と誤認しないこと
  - 上限到達時は停止状態にせず、次回再開のためにカーソルを保存して終了する
- ログには「ジョブ」「query_set_hash」「現在ページ/ startIndex」「累計取得件数」「停止理由（上限/枯渇/エラー）」が追える情報を含める
- エラーハンドリングは現状方針に従う（途中で API エラーが発生した場合の挙動を既存に合わせる）

# テスト要件
- ページングにより複数ページを取得できること（startIndex が進むこと）
- カーソルが永続化され、次回実行で続き（保存された startIndex）から再開すること
- クエリ変更（queries の変更）時に query_set_hash が変わり、旧カーソルを誤って引き継がないこと（jobs.yaml 編集不要）
- 枯渇条件で warn + stop となり、次回 run でも停止が維持されること
- 手動リセット（job 単位）で停止/カーソルが解除され、再開できること
- 既存の Collect / Upsert / Select / Mail のテストがすべてグリーンであること

# 完了条件（Definition of Done）
- 複数ページにまたがる検索結果が Collect で取得できる
- 取得進捗（カーソル）が永続化され、次回以降の実行でも維持される
- 枯渇時は warn を出して停止し、停止状態が次回 run にも反映される
- 手動リセット（job 単位）により停止/カーソルを解除して再開できる
- docs（運用手順）にカーソル/枯渇停止/手動リセットが追記されている
- テストが追加され、既存テストを含めてすべてパスする
